/*for语句的嵌套*/
1，对1到n的阶乘求和，代码如下：
#include <stdio.h>

int main(void){
    int i, j;
    int n = 0;
    int sum = 0;
    int product;
    
    printf("Please input n:")
    scanf("%d",&n);
    /*外层循环，阶乘求和*/
    for(i = 1;i<=n;++i){
        /*内层循环，求i的阶乘*/
        for(j = 1;,product = 1;j <= i;++j){
           product *=j;
        }
        sum += product;
    }
    printf("sum = %d",sum);
    return 0;
 }
 2，输出水仙花数。所谓水仙花数，是指一个三位数，其各位数字立方之和等于该数本身。代码如下:
 #include <stdio.h>
 int main(void){
     int a,b,c;
     int narcissus;
     printf("Naraissus numbers:\n");
     for(a = 1;a < 10; ++a){
         for(b = 0;b < 10; ++b){
            for(c = 0;c < 10; ++c){
                narcissus = a * 100 + b * 10 + c;
                
                if(a*a*a + b*b*b + c*c*c == narcissus)
                    printf("%5d",narcissus);
            }
         }
     }
  printf("\n");
  
  return 0;
  }
  运行结果为：
    153  370  371  407
/*while语句示例*/
1，求Fibonacci数列
Fibonacci数列有以下特点，其第一第二项均为1，从第三个数开始，该数是前两个数的和，即：
                        1                        n = 1
                F（n）= 1                        n = 2
                        F(n - 2) + F(N - 1)      n > 2
求小于n的最大Fibonacci数，代码如下：
#include <stdio.h>

int main(void){
    int n = 0;
    int tmp = 0;
    int f1 = 1;
    int f2 = 1;
    
    printf("Please input n:");
    scanf("%d",&n);
    
    /*求小于n的最大fibonacci数*/
    while(f2 < 2){
        /*f1为上一个fibonacci数，f2为本次得到的fibonacci数*/
        tmp = f2;
        f2 = f1 + f2;
        f1 = tmp;
    }
    /*f1为小于n的最大fibonacci数，f2为大于或等于n的最小fibonacci数*/
    printf("The maximal fibonacci number less than %d is %d.\n",n.f1,);
    
    return 0;
 }
 输出结果为：
           Please input n:14
           The maximal number less than 14 is 13.
 2，求两个整数的最大公约数和最小公倍数，算法步骤如下：
 （1）对已知的两个整数m和n，使m大于或等于n
 （2）m除以n得余数r
 （3）若余数r等于0，则n为求得的最大公约数，算法结束
 （4）若r不等于0，将n置为r，将m置为n，继续执行第二步
  在得到m和n的最大公约数后，可以下式得到两者的最小公倍数：最小公倍数=两个整数之积/最大公约数
  实现代码如下：
  #include <stdio.h>
  
  int main(void){
  int m,n,r;
  int product;
  int tmp;
  
  printf("Please input two numbers:\n");
  scanf("%d %d",m,n);
  
  product = m *n;
  
  if(m<n){
      /*交换m和n*/
      tmp = m;
      m = n;
      n = tmp;
  }
  
  /*使用辗转相除法求最大公约数*/
  r = m % n;
  while(r! = 0){
      m = n;
      n = r;
      r = m & n;
  }
  
  /*输出结果*/
  printf("最大公约数为：%d\n",n);
  printf("最小公倍数为：%d\n",product/n);
  
  return 0;
  }
  
  
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
